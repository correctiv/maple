{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app.riot","webpack:///./src/index.js","webpack:///./node_modules/riot/riot.esm.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","props","message","__webpack_exports__","riot","_app_riot__WEBPACK_IMPORTED_MODULE_1__","component","App","mountApp","document","getElementById","__","install","mount","register","uninstall","unmount","unregister","version","COMPONENTS_IMPLEMENTATION_MAP","Map","DOM_COMPONENT_INSTANCE_PROPERTY","PLUGINS_SET","Set","IS_DIRECTIVE","VALUE_ATTRIBUTE","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","freeze","SIMPLE","bindingTypes","EACH","IF","TAG","SLOT","append","parent","children","start","end","before","insertBefore","fragment","ownerDocument","createDocumentFragment","appendChild","eqeq","a","b","identity","O","indexOf","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","length","next","list","nextSibling","remove","removeChild","range","createRange","setStartBefore","setEndAfter","deleteContents","findK","ktr","j","lo","hi","mid","smartDiff","parentNode","futureNodes","futureStart","futureEnd","futureChanges","currentNodes","currentStart","currentEnd","currentChanges","currentLength","diff","live","currentIndex","set","has","applyDiff","rows","cols","v","k","pv","cv","pd","outer","Array","diffIdx","OND","minLen","link","tresh","keymap","idxInOld","newi","oldi","prev","ptr","HS","EachBinding","seal","childrenMap","node","root","condition","evaluate","template","nodes","getKey","indexName","itemName","afterPlaceholder","placeholder","[object Object]","scope","parentScope","this","update","collection","items","from","newChildrenMap","batches","binding","forEach","item","index","context","_ref2","extendScope","oldItem","Boolean","mustFilterItem","componentTemplate","clone","el","cloneNode","push","delete","createPatch","options","currentSame","futureSame","isReversed","domdiff","patch","values","unmountRedundant","fn","redundant","info","pop","map","_ref","IfBinding","swap","mustMount","mustUnmount","inNode","outNode","ATTRIBUTE","expressionTypes","EVENT","TEXT","VALUE","REMOVE_ATTRIBUTE","SET_ATTIBUTE","attributeExpression","_ref6","oldValue","getMethod","normalizeValue","attributes","entries","_ref5","setAllAttributes","keys","attribute","removeAttribute","removeAllAttributes","normalizeValue$1","expressions","1","_ref7","2","_ref8","childNodeIndex","target","childNodes","val","nodeType","Node","COMMENT_NODE","textNode","createTextNode","replaceChild","data","3","expression","Expression","apply","type","create$2","assign","SlotBinding","templateData","slots","find","_ref10","id","create$6","html","bindings","createDOM","moveSlotInnerContent","slot","firstChild","slotBindings","reduce","acc","_ref12","concat","TagBinding","tag","getComponent","slotsToMarkup","attr","getTag","_ref4","_ref9","method","0","_ref3","offset","_ref13","4","_ref11","createDOMTree","owner","ownerSVGElement","isSvg","container","importNode","window","DOMParser","parseFromString","documentElement","creteSVGTree","createElement","innerHTML","content","createHTMLTree","SVG_RE","injectDOM","dom","test","tagName","moveChildren","source","TemplateChunk","bindingsData","createTemplateDOM","Error","selector","redundantAttribute","querySelector","create$5","mustRemoveRoot","cleanNode","isFunction","panic","error","callOrAssign","constructor","dashToCamelCase","string","replace","_","toUpperCase","noop","writable","configurable","defineProperties","properties","domToArray","els","isArray","toString","normalize","attrs","prop","setAttribute","names","parseNodes","getName","element","toLowerCase","$","ctx","querySelectorAll","CSS_BY_NAME","getStyleNode","style","head","cssManager","css","inject","join","COMPONENT_CORE_HELPERS","COMPONENT_LIFECYCLE_METHODS","shouldUpdate","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","MOCKED_TEMPLATE_INTERFACE","createComponent","templateFn","components","componentTemplateFactory","camelToDashCase","createSubcomponents","componentAPI","defineComponent","state","preserveRoot","add","curry","_len","arguments","_key","_len2","args","_key2","enhanceComponentAPI","defaults","evaluateProps","attributeExpressions","DOMattributesToObject","computeState","oldState","newState","initialProps","runPlugins","updateValues","e","createAttributeBindings","addCssHook","newProps","filter","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","componentName","mountComponent","plugin","implementation","fns","f","g","compose"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","<app>\n  <h2>Hello, i am the app</h2>\n  <p>{ props.message }</p>\n</app>\n","// styles\nimport '~/index.scss'\n\nimport App from '~/app.riot'\n\n\nconst mountApp = riot.component(App)\n\nconst app = mountApp(\n  document.getElementById('app'),\n  { message: 'Hello World' }\n)\n","/* Riot v4.1.1, @license MIT */\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  const children = node.childNodes;\n  Array.from(children).forEach(n => node.removeChild(n));\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n/* get rid of the @ungap/essential-map polyfill */\n\nconst append = (get, parent, children, start, end, before) => {\n  if (end - start < 2) parent.insertBefore(get(children[start], 1), before);else {\n    const fragment = parent.ownerDocument.createDocumentFragment();\n\n    while (start < end) fragment.appendChild(get(children[start++], 1));\n\n    parent.insertBefore(fragment, before);\n  }\n};\n\nconst eqeq = (a, b) => a == b;\n\nconst identity = O => O;\n\nconst indexOf = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\n\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n\n  return futureEnd === 0;\n};\n\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\n\nconst remove = (get, parent, children, start, end) => {\n  if (end - start < 2) parent.removeChild(get(children[start], -1));else {\n    const range = parent.ownerDocument.createRange();\n    range.setStartBefore(get(children[start], -1));\n    range.setEndAfter(get(children[end - 1], -1));\n    range.deleteContents();\n  }\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const keymap = new Map();\n\n  for (let i = currentStart; i < currentEnd; i++) keymap.set(currentNodes[i], i);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const idxInOld = keymap.get(futureNodes[i]);\n\n    if (idxInOld != null) {\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = new Map();\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.set(futureNodes[futureStart], 1);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (live.has(currentNodes[currentStart])) currentStart++;else remove(get, parentNode, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, parentNode, currentNodes, currentStart, i);\n        remove(get, parentNode, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  childrenMap: null,\n  node: null,\n  root: null,\n  condition: null,\n  evaluate: null,\n  template: null,\n  nodes: [],\n  getKey: null,\n  indexName: null,\n  itemName: null,\n  afterPlaceholder: null,\n  placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder\n    } = this;\n    const collection = this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    if (futureNodes.length) {\n      domdiff(parent, this.nodes, futureNodes, {\n        before: placeholder,\n        node: patch(Array.from(this.childrenMap.values()), parentScope)\n      });\n    } else {\n      // remove all redundant templates\n      unmountRedundant(this.childrenMap);\n    } // trigger the mounts and the updates\n\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    unmountRedundant(this.childrenMap, parentScope);\n    this.childrenMap = new Map();\n    this.nodes = [];\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const {\n        template,\n        context\n      } = redundant.pop(); // notice that we pass null as last argument because\n      // the root node and its children will be removed by domdiff\n\n      template.unmount(context, parentScope, null);\n    }\n\n    return item;\n  };\n}\n/**\n * Unmount the remaining template instances\n * @param   {Map} childrenMap - map containing the children template to unmount\n * @param   {*} parentScope - scope of the parent template\n * @returns {TemplateChunk[]} collection containing the template chunks unmounted\n */\n\n\nfunction unmountRedundant(childrenMap, parentScope) {\n  return Array.from(childrenMap.values()).map((_ref) => {\n    let {\n      template,\n      context\n    } = _ref;\n    return template.unmount(context, parentScope, true);\n  });\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref2) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref2;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n\n    if (!oldItem) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n\n\n    futureNodes.push(el); // delete the old item from the children map\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref3) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref3;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  const offset = Array.from(parent.childNodes).indexOf(node);\n  parent.insertBefore(placeholder, node);\n  parent.removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    offset,\n    condition,\n    evaluate,\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n/**\n * Binding responsible for the `if` directive\n */\n\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  placeholder: null,\n  template: '',\n\n  // API methods\n  mount(scope, parentScope) {\n    swap(this.placeholder, this.node);\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    switch (true) {\n      case mustMount:\n        swap(this.node, this.placeholder);\n\n        if (this.template) {\n          this.template = this.template.clone();\n          this.template.mount(this.node, scope, parentScope);\n        }\n\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        swap(this.placeholder, this.node);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    const {\n      template\n    } = this;\n\n    if (template) {\n      template.unmount(scope, parentScope);\n    }\n\n    return this;\n  }\n\n});\n\nfunction swap(inNode, outNode) {\n  const parent = outNode.parentNode;\n  parent.insertBefore(inNode, outNode);\n  parent.removeChild(outNode);\n}\n\nfunction create$1(node, _ref4) {\n  let {\n    evaluate,\n    template\n  } = _ref4;\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder: document.createTextNode(''),\n    template: template.createDOM(node)\n  });\n}\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref5) => {\n    let [name, value] = _ref5;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing all the attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref6, value, oldValue) {\n  let {\n    name\n  } = _ref6;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    } else if (oldValue) {\n      // otherwise remove all the old attributes\n      removeAllAttributes(node, oldValue);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (typeof value === 'boolean') {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\n\nfunction getMethod(value) {\n  return value && typeof value !== 'object' ? SET_ATTIBUTE : REMOVE_ATTRIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction eventExpression(node, _ref7, value) {\n  let {\n    name\n  } = _ref7;\n  node[name] = value;\n}\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {number} expression.childNodeIndex - index to find the text node to update\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction textExpression(node, _ref8, value) {\n  let {\n    childNodeIndex\n  } = _ref8;\n  const target = node.childNodes[childNodeIndex];\n  const val = normalizeValue$1(value); // replace the target if it's a placeholder comment\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode(val);\n    node.replaceChild(textNode, target);\n  } else {\n    target.data = normalizeValue$1(val);\n  }\n}\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\n\nfunction normalizeValue$1(value) {\n  return value != null ? value : '';\n}\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction valueExpression(node, expression, value) {\n  node.value = value;\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = Object.seal({\n  // Static props\n  node: null,\n  value: null,\n\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, data, {\n    node\n  });\n}\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\n\n\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref9) {\n  let {\n    expressions\n  } = _ref9;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  name: null,\n  template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref10) => {\n      let {\n        id\n      } = _ref10;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, parentScope);\n      moveSlotInnerContent(this.node);\n    }\n\n    parentNode.removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template && parentScope) {\n      this.template.update(parentScope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    if (this.template) {\n      this.template.unmount(parentScope);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @returns {undefined} it's a void function\n */\n\nfunction moveSlotInnerContent(slot) {\n  if (slot.firstChild) {\n    slot.parentNode.insertBefore(slot.firstChild, slot);\n    moveSlotInnerContent(slot);\n  }\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref11) {\n  let {\n    name\n  } = _ref11;\n  return Object.assign({}, SlotBinding, {\n    node,\n    name\n  });\n}\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref12) => {\n    let {\n      bindings\n    } = _ref12;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  name: null,\n  slots: null,\n  tag: null,\n  attributes: null,\n  getComponent: null,\n\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount() {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(true);\n    }\n\n    return this;\n  }\n\n});\n\nfunction create$4(node, _ref13) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref13;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @returns {Expression} Expression object\n */\n\nfunction create$5(root, binding) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute); // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: expressions || []\n  }));\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n} // in this case a simple innerHTML is enough\n\n\nfunction createHTMLTree(html) {\n  const template = document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction creteSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return creteSVGTree(html, root);\n  return createHTMLTree(html);\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\n/* istanbul ignore next */\n\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n\nconst SVG_RE = /svg/i;\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  if (SVG_RE.test(el.tagName)) {\n    moveChildren(dom, el);\n  } else {\n    el.appendChild(dom);\n  }\n}\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  bindings: null,\n  bindingsData: null,\n  html: null,\n  dom: null,\n  el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope) {\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope);\n    this.el = el; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n    if (this.dom) injectDOM(el, this.dom.cloneNode(true)); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean} mustRemoveRoot - if true remove the root element\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope));\n\n      if (mustRemoveRoot && this.el.parentNode) {\n        this.el.parentNode.removeChild(this.el);\n      } else if (mustRemoveRoot !== null) {\n        cleanNode(this.el);\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\n/* eslint-disable fp/no-mutating-methods */\n/**\n * Throw an error\n * @param {string} error - error message\n * @returns {undefined} it's a IO void function\n */\n\nfunction panic(error) {\n  throw new Error(error);\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref) => {\n    let [key, value] = _ref;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n} // doese simply nothing\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\n\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === expressionTypes.ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === expressionTypes.VALUE:\n        acc[VALUE_ATTRIBUTE] = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  shouldUpdate: noop,\n  onBeforeMount: noop,\n  onMounted: noop,\n  onBeforeUpdate: noop,\n  onUpdated: noop,\n  onBeforeUnmount: noop,\n  onUnmounted: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = {\n  update: noop,\n  mount: noop,\n  unmount: noop,\n  clone: noop,\n  createDOM: noop\n  /**\n   * Factory function to create the component templates only once\n   * @param   {Function} template - component template creation function\n   * @param   {Object} components - object containing the nested components\n   * @returns {TemplateChunk} template chunk object\n   */\n\n};\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref2) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    state: {}\n  })), Object.assign({\n    // defined during the component creation\n    slots: null,\n    root: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Evaluate the component properties either from its real attributes or from its attribute expressions\n * @param   {HTMLElement} element - component root\n * @param   {Array}  attributeExpressions - attribute values generated via createAttributeBindings\n * @returns {Object} attributes key value pairs\n */\n\nfunction evaluateProps(element, attributeExpressions) {\n  if (attributeExpressions === void 0) {\n    attributeExpressions = [];\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), evaluateAttributeExpressions(attributeExpressions));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n\n  const updateValues = method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  };\n\n  return Object.assign(binding, {\n    expressions,\n    mount: updateValues('mount'),\n    update: updateValues('update'),\n    unmount: updateValues('unmount')\n  });\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, 'is', name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  const initialProps = callOrAssign(props);\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      this.props = Object.freeze(Object.assign({}, initialProps, evaluateProps(element, this[ATTRIBUTES_KEY_SYMBOL].expressions)));\n      this.state = computeState(this.state, state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      element[DOM_COMPONENT_INSTANCE_PROPERTY] = this; // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, 'root', element); // define the slots array\n\n      defineProperty(this, 'slots', slots); // before mount lifecycle event\n\n      this.onBeforeMount(this.props, this.state); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this.onMounted(this.props, this.state);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateProps(this.root, this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this.shouldUpdate(newProps, this.props) === false) return;\n      this.props = Object.freeze(Object.assign({}, initialProps, newProps));\n      this.state = computeState(this.state, state);\n      this.onBeforeUpdate(this.props, this.state);\n      this[TEMPLATE_KEY_SYMBOL].update(this, parentScope);\n      this.onUpdated(this.props, this.state);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this.onBeforeUnmount(this.props, this.state);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount();\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, {}, !preserveRoot);\n      this.onUnmounted(this.props, this.state);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount();\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already install');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helpter method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return (el, props) => compose(c => c.mount(el), c => c({\n    props\n  }), createComponent)(implementation);\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.1.1'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, register, uninstall, unmount, unregister, version };\n"],"sourceRoot":""}